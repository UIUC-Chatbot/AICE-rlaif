{"Title": ["", "GitHub - Nerdylicious/DijkstraShortestPath: Implementation of Dijkstra's algorithm in C++ which finds the shortest path from a start node to every other node in a weighted graph.", "GitHub - dtnewman/djikstra_shortest_path: A C++ implementation of Djikstra's algorithm", "Dijkstra's Algorithm", "GitHub - MichaelKeist/Dijkstra-CPP: An implementation of dijkstra's algorithm for finding the shortest path between two nodes on a graph. The python script generates the graph, the c++ program reads in the python script output, actually creates the graph, and executes the algorithm.", "C++ Programming Code Examples", "GitHub - hamzaelanssari/Shortest-path-algorithm-with-C: shortest path between cities with language C", "GitHub - gracexiaoyan/Dijkstra: Dijkstra to get the shortest distance in directed graph", "", "GitHub - matrixgardener/AlgorithmCode: algorithm code"], "url": ["https://compprog.files.wordpress.com/2008/01/dijkstra.c", "https://github.com/Nerdylicious/DijkstraShortestPath", "https://github.com/dtnewman/djikstra_shortest_path", "http://www.cs.cmu.edu/~crpalmer/sp/", "https://github.com/MichaelKeist/Dijkstra-CPP", "https://cplusplus.happycodings.com/computer-graphics/use-the-bellman-ford-algorithm-to-find-the-shortest-path-between-two-vertices-assuming-that.html", "https://github.com/hamzaelanssari/Shortest-path-algorithm-with-C", "https://github.com/gracexiaoyan/Dijkstra", "https://www.ics.uci.edu/~eppstein/161/python/prim.py", "https://github.com/matrixgardener/AlgorithmCode"], "Score": [0.20252379775047302, 0.188504159450531, 0.18526211380958557, 0.18490831553936005, 0.18394280970096588, 0.17989155650138855, 0.17925381660461426, 0.1769753247499466, 0.17687159776687622, 0.17600692808628082], "Text": ["#include \n#define GRAPHSIZE 2048\n#define INFINITY GRAPHSIZE*GRAPHSIZE\n#define MAX(a, b) ((a > b) ? (a) : (b))\nint e; /* The number of nonzero edges in the graph */\nint n; /* The number of nodes in the graph */\nlong dist[GRAPHSIZE][GRAPHSIZE]; /* dist[i][j] is the distance between node i and j; or 0 if there is no direct connection */\nlong d[GRAPHSIZE]; /* d[i] is the length of the shortest path between the source (s) and node i */\nint prev[GRAPHSIZE]; /* prev[i] is the node that comes right before i in the shortest path from the source to i*/\nvoid printD() {\n\tint i;\n\tprintf(\"Distances:\\n\");\n\tfor (i = 1; i <= n; ++i)\n\tprintf(\"%10d\", i);\n\tprintf(\"\\n\");\n\tfor (i = 1; i <= n; ++i) {\n\tprintf(\"%10ld\", d[i]);\n\t}\n\tprintf(\"\\n\");\n}\n/*\n * Prints the shortest path from the source to dest.\n *\n * dijkstra(int) MUST be run at least once BEFORE\n * this is called\n */\nvoid printPath(int dest) {\n\tif (prev[dest] != -1)\n\tprintPath(prev[dest]);\n\tprintf(\"%d \", dest);\n}\nvoid dijkstra(int s) {\n\tint i, k, mini;\n\tint visited[GRAPHSIZE];\n\tfor (i = 1; i <= n; ++i) {\n\td[i] = INFINITY;\n\tprev[i] = -1; /* no path has yet been found to i */\n\tvisited[i] = 0; /* the i-th element has not yet been visited */\n\t}\n\td[s] = 0;\n\tfor (k = 1; k <= n; ++k) {\n\tmini = -1;\n\tfor (i = 1; i <= n; ++i)\n\tif (!visited[i] && ((mini == -1) || (d[i] < d[mini])))\n\tmini = i;\n\tvisited[mini] = 1;\n\tfor (i = 1; i <= n; ++i)\n\tif (dist[mini][i])\n\tif (d[mini] + dist[mini][i] < d[i]) {\n\td[i] = d[mini] + dist[mini][i];\n\tprev[i] = mini;\n\t}\n\t}\n}\nint main(int argc, char *argv[]) {\n\tint i, j;\n\tint u, v, w;\n\tFILE *fin = fopen(\"dist.txt\", \"r\");\n\tfscanf(fin, \"%d\", &e);\n\tfor (i = 0; i < e; ++i)\n\tfor (j = 0; j < e; ++j)\n\tdist[i][j] = 0;\n\tn = -1;\n\tfor (i = 0; i < e; ++i) {\n\tfscanf(fin, \"%d%d%d\", &u, &v, &w);\n\tdist[u][v] = w;\n\tn = MAX(u, MAX(v, n));\n\t}\n\tfclose(fin);\n\tdijkstra(1);\n\tprintD();\n\tprintf(\"\\n\");\n\tfor (i = 1; i <= n; ++i) {\n\tprintf(\"Path to %d: \", i);\n\tprintPath(i);\n\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n", "Skip to content\n Toggle navigation\n Sign up\n * Product\n + Actions\n Automate any workflow\n + Packages\n Host and manage packages\n + Security\n Find and fix vulnerabilities\n + Codespaces\n Instant dev environments\n + Copilot\n Write better code with AI\n + Code review\n Manage code changes\n + Issues\n Plan and track work\n + Discussions\n Collaborate outside of code\n + Explore\n + All features\n + Documentation\n + GitHub Skills\n + Blog\n * Solutions\n + For\n + Enterprise\n + Teams\n + Startups\n + Education\n + By Solution\n + CI/CD & Automation\n + DevOps\n + DevSecOps\n + Case Studies\n + Customer Stories\n + Resources\n * Open Source\n + GitHub Sponsors\n Fund open source developers\n + The ReadME Project\n GitHub community articles\n + Repositories\n + Topics\n + Trending\n + Collections\n * Pricing\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n * No suggested jump to results\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n * In this user All GitHub \u21b5\n Jump to \u21b5\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n Sign in\n Sign up\n {{ message }}\n Nerdylicious / DijkstraShortestPath Public\n * Notifications\n * Fork 9\n * Star 32\n\n Implementation of Dijkstra's algorithm in C++ which finds the shortest path from a start node to every other node in a weighted graph.\n\n 32 stars 9 forks\n Star\n Notifications\n * Code\n * Issues 0\n * Pull requests 0\n * Actions\n * Projects 0\n * Wiki\n * Security\n * Insights\n More\n * Code\n * Issues\n * Pull requests\n * Actions\n * Projects\n * Wiki\n * Security\n * Insights\n\n Nerdylicious/DijkstraShortestPath\n\n This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.\n master\n Switch branches/tags\n Branches Tags\n Could not load branches\n Nothing to show\n {{ refName }} default\n View all branches\n Could not load tags\n Nothing to show\n {{ refName }} default\n View all tags\n\n Name already in use\n\n A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch?\n Cancel Create\n 1 branch 0 tags\n Code\n * Local\n * Codespaces\n * Clone\n HTTPS GitHub CLI\n\n Use Git or checkout with SVN using the web URL.\n\n Work fast with our official CLI. Learn more.\n\n * Open with GitHub Desktop\n * Download ZIP\n\n Sign In Required\n\n Please sign in to use Codespaces.\n\n Launching GitHub Desktop\n\n If nothing happens, download GitHub Desktop and try again.\n\n Launching GitHub Desktop\n\n If nothing happens, download GitHub Desktop and try again.\n\n Launching Xcode\n\n If nothing happens, download Xcode and try again.\n\n Launching Visual Studio Code\n\n Your codespace will open once ready.\n\n There was a problem preparing your codespace, please try again.\n\n Latest commit\n\n Git stats\n\n * 2 commits\n\n Files\n\n Permalink\n Failed to load latest commit information.\n Type\n Name\n Latest commit message\n Commit time\n DijkstraShortestPath.cpp\n README.md\n View code\n\n README.md\n\n Dijkstra's Algorithm\n\n Implementation of Dijkstra's algorithm in C++ which finds the shortest path from a start node to every other node in a weighted graph.\n\n About\n\n Implementation of Dijkstra's algorithm in C++ which finds the shortest path from a start node to every other node in a weighted graph.\n\n Resources\n\n Readme\n\n Stars\n\n 32 stars\n\n Watchers\n\n 2 watching\n\n Forks\n\n 9 forks\n\n Releases\n\n No releases published\n\n Packages 0\n\n No packages published\n\n Languages\n\n * C++ 100.0%\n\n Footer\n\n \u00a9 2023 GitHub, Inc.\n\n Footer navigation\n\n * Terms\n * Privacy\n * Security\n * Status\n * Docs\n * Contact GitHub\n * Pricing\n * API\n * Training\n * Blog\n * About\n You can\u2019t perform that action at this time.\n You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.", "Skip to content\n Toggle navigation\n Sign up\n * Product\n + Actions\n Automate any workflow\n + Packages\n Host and manage packages\n + Security\n Find and fix vulnerabilities\n + Codespaces\n Instant dev environments\n + Copilot\n Write better code with AI\n + Code review\n Manage code changes\n + Issues\n Plan and track work\n + Discussions\n Collaborate outside of code\n + Explore\n + All features\n + Documentation\n + GitHub Skills\n + Blog\n * Solutions\n + For\n + Enterprise\n + Teams\n + Startups\n + Education\n + By Solution\n + CI/CD & Automation\n + DevOps\n + DevSecOps\n + Case Studies\n + Customer Stories\n + Resources\n * Open Source\n + GitHub Sponsors\n Fund open source developers\n + The ReadME Project\n GitHub community articles\n + Repositories\n + Topics\n + Trending\n + Collections\n * Pricing\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n * No suggested jump to results\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n * In this user All GitHub \u21b5\n Jump to \u21b5\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n Sign in\n Sign up\n {{ message }}\n dtnewman / djikstra_shortest_path Public\n * Notifications\n * Fork 2\n * Star 4\n\n A C++ implementation of Djikstra's algorithm\n\n 4 stars 2 forks\n Star\n Notifications\n * Code\n * Issues 0\n * Pull requests 0\n * Actions\n * Projects 0\n * Wiki\n * Security\n * Insights\n More\n * Code\n * Issues\n * Pull requests\n * Actions\n * Projects\n * Wiki\n * Security\n * Insights\n\n dtnewman/djikstra_shortest_path\n\n This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.\n master\n Switch branches/tags\n Branches Tags\n Could not load branches\n Nothing to show\n {{ refName }} default\n View all branches\n Could not load tags\n Nothing to show\n {{ refName }} default\n View all tags\n\n Name already in use\n\n A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch?\n Cancel Create\n 1 branch 0 tags\n Code\n * Local\n * Codespaces\n * Clone\n HTTPS GitHub CLI\n\n Use Git or checkout with SVN using the web URL.\n\n Work fast with our official CLI. Learn more.\n\n * Open with GitHub Desktop\n * Download ZIP\n\n Sign In Required\n\n Please sign in to use Codespaces.\n\n Launching GitHub Desktop\n\n If nothing happens, download GitHub Desktop and try again.\n\n Launching GitHub Desktop\n\n If nothing happens, download GitHub Desktop and try again.\n\n Launching Xcode\n\n If nothing happens, download Xcode and try again.\n\n Launching Visual Studio Code\n\n Your codespace will open once ready.\n\n There was a problem preparing your codespace, please try again.\n\n Latest commit\n\n Git stats\n\n * 3 commits\n\n Files\n\n Permalink\n Failed to load latest commit information.\n Type\n Name\n Latest commit message\n Commit time\n Readme.md\n djikstra_shortest_path.cpp\n View code\n\n Readme.md\n\n Djikstra's Algorithm\n\n In this program, I wrote a program in C++ that uses Djikstra's algorithm to find the shortest path between two nodes in a graph. For more information on Djikstra's algorithm, see Wikipedia's article.\n\n This code compiles with G++.\n\n About\n\n A C++ implementation of Djikstra's algorithm\n\n Resources\n\n Readme\n\n Stars\n\n 4 stars\n\n Watchers\n\n 2 watching\n\n Forks\n\n 2 forks\n\n Releases\n\n No releases published\n\n Packages 0\n\n No packages published\n\n Languages\n\n * C++ 100.0%\n\n Footer\n\n \u00a9 2023 GitHub, Inc.\n\n Footer navigation\n\n * Terms\n * Privacy\n * Security\n * Status\n * Docs\n * Contact GitHub\n * Pricing\n * API\n * Training\n * Blog\n * About\n You can\u2019t perform that action at this time.\n You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.", "\nNotes:\n\nThis algorithm is not presented in the same way that you'll find\n it in most texts because i'm ignored directed vs. undirected graphs\n and i'm ignoring the loop invariant that you'll see in any book\n which is planning on proving the correctness of the algorithm.\n If we are dealing with a di-graph the algorithm will be the same\n with the only difference being the meaning attached to each edge.\n The loop invariant is that at any stage we have partitioned the\n graph into three sets of vertices (S,Q,U), S which are vertices to \n which we know their shortest paths, Q which are ones we have \"queued\"\n knowing that we may deal with them now and U which are the other\n vertices. This information is important in proving the correctness and\n analyzing the running-time of the algorithm and not for understanding\n it (in my humble opinion).\n \nREF: Cormen. Thomas H., Leiserson, Charles E., Rivest, Ronald L.,\n Introduction to Algorithms, MIT Press (1990), pages 527-531\nRevision:\nThe current revision of this page was last modified on August 27, 1998.\n\nGiven a graph G with a weight function wt:E(G)->R which maps the edges\nto a real valued weight and wt(e) > 0 for all e in E(G). NOTE: wt(e) > 0\nis a VERY important assumption. As i've presented the algorith, a weight\nof 0 is not actually a problem (it could be for some implementations) but\na negative weight could/would result in an infinite loop. For example,\n *---- 1 ---*\n \\ /\n -10 1\n \\ /\n \\ /\n *\n\nwill generate paths which cycle endlessly.\n\nYou need an origin vertex (where all the paths are starting from, or,\nmore typically in games, where the paths are ending).\n \nAugment the labels of the vertices by a real value, initially infinity,\nwhich is the shortest weighted path from the origin to this vertex (which\nhas been found so far). Also, augment each vertex with a \"pointer\" to its\nparent in the shortest weighted path found so far, initially have this\npointing nowhere.\n \nYou need a priority queue which is sorted based on the weight of the\nshortest path from the origin to the vertex. When an element is inserted\ninto the priority queue and it already exists, the previous copy must be\nremoved and the new one inserted into the right level [*].\n Take the origin vertex, set the weight of the shortest path to 0 and\npush it onto the priority queue.\nwhile the priority queue is not empty, pop an entry where\n v is the vertex, w_v and p_v are the augmented labels of v.\n foreach edge e=(v,u) in G, where u has augmented labels w_u, p_u.\n if wt(e) + w_v < w_u then\n set p_u to v\n set w_u to wt(e) + w_v\n add to the priority queue.\n\n\nComments:\nTechnically, [*] must be true because otherwise it would be impossible to\nprove the correctness of the algorithm. I've played with an personally\nthink that you can get a better performance (your priority queue becomes\nalmost O(1) with the cost of extra elements building up in the queue)\nby relaxing this restriction and allowing multiple copies of the same\nvertex to accumulate in the queue.\n\nThe net effect will be that some sets of vertices may have to be cycled\nthrough the queue several times (read \"more cost\"). It is my opinion\nthat this additional cost is considerably less than the O(log n) [n is\nthe size of the priority queue] time required to implement this algorithm\nas described above.\n \nHowever, I have not attempted to analyze the worst case effect of relaxing\n[*] and would say to implement it in this way only if you trust my guess.\n \nAlso, note that if you were going to implement a heuristic for directing\nthe search, you wouldn't insert the weight of the shortest path from the\nsource node to this node. Instead, you would insert the weight of the\nshortest path from the source node to this node plus the heuristic's\nestimate of the cost to the destination node. I won't be discussing this\nanymore until the very end of the document.\n Tile/Grid Implementation:\n\n Def: What I mean by \"a game with a grid/tile map\"\n \nA game where the playing area is dividing into\n squares with one or more \"object\" on the square. These objects include\n walls, doors, etc which are assumed to occupy the entire square.\n \nIf you want to apply what i'm going to say where walls do not occupy the\nentire square, you'll need a function wt({x,y}, {x',y'}) which gives the\ncost of moving from (x,y) to (x',y') and otherwise it's the same.\n\nIn a game with a grid map, you need a function (or a table or whatever)\nwhich i'll call wt(x,y) which gives you the \"cost\" of moving onto a\nspecified grid location (x,y). Note: \"moving *onto*\". If you are\nwriting a dungeon based game and you have a teleporter at (a,b) that you don't\nwant the monsters to hit, make wt(a,b) = infinity where infinity is\nsome arbitrarily large number. The same applies to walls, if you have a\nwall square at (a,b) then wt(a,b) = infinity.\n \nFor any square, there are at most 8 squares around it. This is easy to\nimplement with an array that gives the offsets for each square.\n \nWe'll assume that you don't want the shortest paths for the entire world\n(which could be arbitrarily large) but instead want shortest paths for\nonly a limited area, say of width and height 2*DELTA+1.\n \nWe will be storing elements in two arrays in positions [0..2*DELTA] which\ncorrespond to the position on the map (o_x - x + DELTA - 1). To make\nthe pseudo-code more readable, let:\n  f_x(x) = x - o_x + DELTA\n f_y(y) = y - o_y + DELTA\n\nbe two functions which translate the coordinates.\n\nThe following two arrays are used to store the \"augmented\" information\ndiscussed in the earlier explanation. These store the following information:\n w[x'][y'] The weight of the current shortest path from (o_x, o_y) to\n (o_x + x' - DELTA, o_y + y' - DELTA).\np[x'][y'] The parent node of that shortest path\nint w[2*DELTA+1][2*DELTA+1];\nint p[2*DELTA+1][2*DELTA+1][2];\n\n\nAlgorithm: (origin at (o_x, o_y))\n set each w[i][j] = infinity\n set each p[i][j] = (infinity, infinity)\n set w[f_x(o_x)][f_y(o_y)] = 0\n push (o_x, o_y) onto the priority queue, say pq. [**]\n while (pop (x,y) from pq is possible)\n [***]\n foreach each square (x',y') adjacent to (x,y) and where\n |x-o_x| <= DELTA and |y-o_y| <= DELTA\n if w[f_x(x)][f_y(y)] + wt(x',y') < w[f_x(x')][f_y(y')] then\n { we have found a new shortest path }\n w[f_x(x')][f_y(y')] = w[f_x(x)][f_y(y)] + wt(x',y')\n p[f_x(x')][f_y(y')] = (x,y)\n push (x',y') onto the priority queue [**]\n\nAnd you now have the shortest paths from (o_x,o_y) to every square in\nthe range { o_x - DELTA, o_y - DELTA, o_x + DELTA, o_y + DELTA } and\nthis will print the path from some point (x,y) to (o_x, o_y):\ndo\n print (x,y)\n (x,y) = p[f_x(x)][f_(y)]\nwhile (x,y) != (infinity, infinity)\n\nand any square, (x,y), which is not reachable from (o_x, o_y) will have:\np[f_x(x)][f_y(y)] = (infinity, infinity)\nw[f_x(x)][f_y(y)] = infinity\n\n\nSample Code:\nI have written a simple example of implementing this algorithm for a grid\nmap game. The source code is zipped (pkzip). The code itself is quite\nsimple.\nI have been able to compile and run the code on several UNIX boxes and DOS\nwith both the Microsoft C compiler (version 7, I think) and GCC (2.6.3 with\nthe version of DJGPP current as of June 1, 1995). It should be quite easy\nto port to any system. \nIncluded in the source code is a single map which should give you the gist\nof what sort of input it expects and you should read the file sp.c which\nexplains how to use the demo.\n \nThis source code is release with the understanding that I retain ownership\nof the code. You are free to make use of it in any way you see fit and\nby transferring the code, you accept all responsibility for any damages\nwhich result from using it.\n \nHaving accepted that, you may get the source code:\nSample C source code, simple grid map\n \nNOTE I've also got a modified version of the same code with a link\na little further down into the document. The second version can use a simple\nheuristic to find the path quickly.\n Adding a Heuristic\nIf you are more interested in finding the shortest path between two nodes\n(and not all shortest paths to a node), you may be interested in applying\na heuristic function to the search.\n\nAuthor's Note: My apologies on this section. It is not overly\nclear and is a little too brief. If you don't follow what I'm saying,\nyou may wish to look at the source code I've supplied and then compare\nthe algorith in this page to the actual source code. It should be\nfairly clear.\n \nA heuristic function is a fancy way of saying a function which guesses\nat an answer. In this case, our heurisitic function will be guessing\nat the length of the shortest path from any node to the destination node.\n \nIMPORTANT: It is important that your function always be at most the\nreal shortest distance. If you are using a real valued cartesian playing\nfield, you would want to use sqrt(dist(x)^2 + dist(y)^2) distance function.\nUsing a heurtistic function of 0 will get you back to the original algorithm.\n \nThe effect of adding a good heuristic function would be to direct the search\nso that very few bad paths will be considered. I'm not going to bother\nmuch with the theory that this is a shortest path or even why it works.\nIf you're avidly reading this part, you probably just want to get a\nshort path as quickly as possible and are willing to trust a little magic.\n \nTo add the heuristic to my algorithm, let h((x,y), (dest_x, dest_y))\nbe a function which estimates the shortest path betwen two points.\n \nIn the algorith, in each line that has ** beside it, add the heuristic\nfunction applied to the current node. At the point marked with ***\nadd the line:\n\nif (x,y) = (dest_x, dest_y) then done.\n \nAnd voila! You have a function which can rapidly find the shortest path\nbetween any two points.\n \nThe following source code uses exactly the same algorith with a heuristic\nfunction that corresponds to the shortest distance on a grid.\n H(x_1, y_1, x_2, y_2) = max( |x_2 - x_1|, |y_2 - y_1| )\n\nwhich is the shortest possible distance on a grid between the points\n(x_1, y_1) and (x_2, y_2). The only changes to the original source code\nare to add this value to the priority when entries are added to the\npriority queue and a simple if statement which stops processing when we\nhave found the node for which we are searching.\n\nTo compare the different techniques, you can use two command line options.\n-a will request that processing stop when the destination has been\nlocated and -h will request that the heuristic be applied. Thus\nrunning the program with -a and then with -a -h will give you a good\ncomparison between Djisktra's and Djisktra's with the heuristic.\n \nDisclaimer I have not compiled this code on any machine except\na DEC Alpha (OSF). The zip file was created using that system's\nzip command. I don't guarantee that anyone else will be able to get and\ncompile this code. For this reason, I'm continuing to provide the original\nsource code (just in case).\n \nSample C source code, Djisktra's with a heuristic\n  A* vs. Dijkstra \n\nIf you are familiar with the A* algorithm, you might notice that adding\nthe heuristic to Dijkstra's algorithm gives you something very similar.\nBasically, Dijkstra's algorithm with a heuristic is equivalent to A*\nexcept for a couple of technical facts:\n \n  A* will generally use less memory\n   You must know the entire search space to use Dijkstra's algorithm\n \n\nFor people that are writing tile based games, I would actually\nrecommend that they use Dijkstra's algorithm because it is easier to\ncode and will be about as efficient as A*.\n \nFeel free to send any comments, criticism et al to me.\n\nChris Palmer\ncrpalmer+@cs.cmu.edu\n\n", " \n  \n \n \n \n\n \n \n \n \n  Name already in use\n  \n \n \n \n \n \n  A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch?\n\n \n \n\n \n \n \n 1\n branch\n \n \n \n 0\n tags\n \n \n \n \n \n \n \n \n Code\n \n \n  \n \n \n \n\n \n \n \n \n Use Git or checkout with SVN using the web URL.\n \n \n \n\n\n \n \n Open with GitHub Desktop\n \n\n \n \n Download ZIP\n \n \n\n \n\n \n \n \n \n \n \n \n\n \n Latest commit\n \n \n Files\n \n \n Permalink\n \n \n \n Failed to load latest commit information.\n \n  \n Type\n Name\n Latest commit message\n Commit time\n \n\n \n\n \n About\n \n An implementation of dijkstra's algorithm for finding the shortest path between two nodes on a graph. The python script generates the graph, the c++ program reads in the python script output, actually creates the graph, and executes the algorithm.\n \nStars\n\n \n \n 1\n star\n \nWatchers\n\n \n \n 1\n watching\n \nForks\n\n \n \n 0\n forks\n \n \n \n", " \n\n\n\n\nC++ Programming Code Examples\nC++ > Computer Graphics Code Examples\nUse the Bellman-Ford Algorithm to Find the Shortest Path Between Two Vertices Assuming that\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n\n/* Use the Bellman-Ford Algorithm to Find the Shortest Path Between Two Vertices Assuming that\nNegative Size Edges Exist in the Graph \nThis is a C++ Program to find the shortest path algorithm using Bellman-Ford algorithm. This algorithm also entertains negative edge weights. */\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n #include <limits.h>\n // a structure to represent a weighted edge in graph\n struct Edge\n {\n int src, dest, weight;\n };\n // a structure to represent a connected, directed and weighted graph\n struct Graph\n {\n // V-> Number of vertices, E-> Number of edges\n int V, E;\n // graph is represented as an array of edges.\n struct Edge* edge;\n };\n // Creates a graph with V vertices and E edges\n struct Graph* createGraph(int V, int E)\n {\n struct Graph* graph = (struct Graph*) malloc(sizeof(struct Graph));\n graph->V = V;\n graph->E = E;\n graph->edge = (struct Edge*) malloc(graph->E * sizeof(struct Edge));\n return graph;\n }\n // A utility function used to print the solution\n void printArr(int dist[], int n)\n {\n printf(\"Vertex Distance from Source\\n\");\n for (int i = 0; i < n; ++i)\n printf(\"%d \\t\\t %d\\n\", i, dist[i]);\n }\n // The main function that finds shortest distances from src to all other vertices using Bellman-Ford algorithm. The function also detects negative weight cycle\n void BellmanFord(struct Graph* graph, int src)\n {\n int V = graph->V;\n int E = graph->E;\n int dist[V];\n // Step 1: Initialize distances from src to all other vertices as INFINITE\n for (int i = 0; i < V; i++)\n dist[i] = INT_MAX;\n dist[src] = 0;\n // Step 2: Relax all edges |V| - 1 times. A simple shortest path from src to any other vertex can have at-most |V| - 1 edges\n for (int i = 1; i <= V - 1; i++)\n {\n for (int j = 0; j < E; j++)\n {\n int u = graph->edge[j].src;\n int v = graph->edge[j].dest;\n int weight = graph->edge[j].weight;\n if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\n dist[v] = dist[u] + weight;\n }\n }\n // Step 3: check for negative-weight cycles. The above step guarantees shortest distances if graph doesn't contain negative weight cycle. If we get a shorter path, then there is a cycle.\n for (int i = 0; i < E; i++)\n {\n int u = graph->edge[i].src;\n int v = graph->edge[i].dest;\n int weight = graph->edge[i].weight;\n if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\n printf(\"Graph contains negative weight cycle\");\n }\n printArr(dist, V);\n return;\n }\n // Driver program to test above functions\n int main()\n {\n /* Let us create the graph given in above example */\n int V = 5; // Number of vertices in graph\n int E = 8; // Number of edges in graph\n struct Graph* graph = createGraph(V, E);\n // add edge 0-1 (or A-B in above figure)\n graph->edge[0].src = 0;\n graph->edge[0].dest = 1;\n graph->edge[0].weight = -1;\n // add edge 0-2 (or A-C in above figure)\n graph->edge[1].src = 0;\n graph->edge[1].dest = 2;\n graph->edge[1].weight = 4;\n // add edge 1-2 (or B-C in above figure)\n graph->edge[2].src = 1;\n graph->edge[2].dest = 2;\n graph->edge[2].weight = 3;\n // add edge 1-3 (or B-D in above figure)\n graph->edge[3].src = 1;\n graph->edge[3].dest = 3;\n graph->edge[3].weight = 2;\n // add edge 1-4 (or A-E in above figure)\n graph->edge[4].src = 1;\n graph->edge[4].dest = 4;\n graph->edge[4].weight = 2;\n // add edge 3-2 (or D-C in above figure)\n graph->edge[5].src = 3;\n graph->edge[5].dest = 2;\n graph->edge[5].weight = 5;\n // add edge 3-1 (or D-B in above figure)\n graph->edge[6].src = 3;\n graph->edge[6].dest = 1;\n graph->edge[6].weight = 1;\n // add edge 4-3 (or E-D in above figure)\n graph->edge[7].src = 4;\n graph->edge[7].dest = 3;\n graph->edge[7].weight = -3;\n BellmanFord(graph, 0);\n return 0;\n }\n\n\n  sizeof() Operator in C++  The sizeof() is an operator that evaluates the size of data type, constants, variable. It is a compile-time operator as it returns the size of any variable or a constant at the compilation time. The size, which is calculated by the sizeof() operator, is the amount of RAM occupied in the computer.\nThe sizeof is a keyword, but it is a compile-time operator that determines the size, in bytes, of a variable or data type. The sizeof operator can be used to get the size of classes, structures, unions and any other user defined data type.\n   Syntax for sizeof() Operator in C++  \n data_type  data type whose size is to be calculated\nThe data_type can be the data type of the data, variables, constants, unions, structures, or any other user-defined data type.\nIf the parameter of a sizeof() operator contains the data type of a variable, then the sizeof() operator will return the size of the data type.\nsizeof() may give different output according to machine, we have run our program on 32 bit gcc compiler.\n \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n/* The sizeof() is an operator in C and C++. It is an unary operator which assists a programmer in finding the size of the operand which is being used. */\n#include <iostream>\nusing namespace std;\nint main() {\n int arr[]={10,20,30,40,50};\n std::cout << \"Size of the array 'arr' is : \"<<sizeof(arr) << std::endl;\n cout << \"Size of char : \" << sizeof(char) << endl;\n cout << \"Size of int : \" << sizeof(int) << endl;\n cout << \"Size of short int : \" << sizeof(short int) << endl;\n cout << \"Size of long int : \" << sizeof(long int) << endl;\n cout << \"Size of float : \" << sizeof(float) << endl;\n cout << \"Size of double : \" << sizeof(double) << endl;\n cout << \"Size of wchar_t : \" << sizeof(wchar_t) << endl;\n return 0;\n}\n\n\n  IOS Library eof() Function in C++  Check whether eofbit is set. Returns true if the eofbit error state flag is set for the stream. This flag is set by all standard input operations when the End-of-File is reached in the sequence associated with the stream.\nNote that the value returned by this function depends on the last operation performed on the stream (and not on the next).\nOperations that attempt to read at the End-of-File fail, and thus both the eofbit and the failbit end up set. This function can be used to check whether the failure is due to reaching the End-of-File or to some other reason.\n   Syntax for IOS eof() Function in C++  \n\nThis function does not accept any parameter.\nFunction returns true if the stream's eofbit error state flag is set (which signals that the End-of-File has been reached by the last input operation).\nfalse otherwise.\n  Data races  Accesses the stream object. Concurrent access to the same stream object may cause data races.\n  Exception safety  Strong guarantee: if an exception is thrown, there are no changes in the stream.\n \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n/* The eof() method of ios class in C++ is used to check if the stream is has raised any EOF (End Of File) error. It means that this function will check if this stream has its eofbit set. */\n// C++ code example to demonstrate the working of eof() function\n#include <iostream>\n#include <fstream>\nint main () {\n std::ifstream is(\"example.txt\");\n char c;\n while (is.get(c))\n std::cout << c;\n if (is.eof())\n std::cout << \"[EoF reached]\\n\";\n else\n std::cout << \"[error reading]\\n\";\n is.close();\n return 0;\n}\n\n\n  Nested Loop Statement in C++  C supports nesting of loops in C. Nesting of loops is the feature in C that allows the looping of statements inside another loop. Any number of loops can be defined inside another loop, i.e., there is no restriction for defining any number of loops. The nesting level can be defined at n times. You can define any type of loop inside another loop; for example, you can define 'while' loop inside a 'for' loop.\nA loop inside another loop is called a nested loop. The depth of nested loop depends on the complexity of a problem. We can have any number of nested loops as required. Consider a nested loop where the outer loop runs n times and consists of another loop inside it. The inner loop runs m times. Then, the total number of times the inner loop runs during the program execution is n*m.\n   Syntax for Nested Loop Statement in C++  \n  Outer_loop\n {\n Inner_loop\n {\n // inner loop statements.\n }\n // outer loop statements.\n }   \nOuter_loop and Inner_loop are the valid loops that can be a 'for' loop, 'while' loop or 'do-while' loop.\n \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n/* nested loop statement in C++ language */\n// C++ program that uses nested for loop to print a 2D matrix\n#include <bits/stdc++.h>\nusing namespace std;\n#define ROW 3\n#define COL 3\n// Driver program\nint main()\n{\n int i, j;\n // Declare the matrix\n int matrix[ROW][COL] = { { 4, 8, 12 },\n { 16, 20, 24 },\n { 28, 32, 36 } };\n cout << \"Given matrix is \\n\";\n // Print the matrix using nested loops\n for (i = 0; i < ROW; i++) {\n for (j = 0; j < COL; j++)\n cout << matrix[i][j];\n cout << \"\\n\";\n }\n return 0;\n}\n\n\n  For Loop Statement in C++  In computer programming, loops are used to repeat a block of code. For example, when you are displaying number from 1 to 100 you may want set the value of a variable to 1 and display it 100 times, increasing its value by 1 on each loop iteration. When you know exactly how many times you want to loop through a block of code, use the for loop instead of a while loop. A for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.\n   Syntax of For Loop Statement in C++  \n for (initialization; condition; update) {\n // body of-loop\n} \n initialization  initializes variables and is executed only once.\n  condition  if true, the body of for loop is executed, if false, the for loop is terminated.\n  update  updates the value of initialized variables and again checks the condition.\nA new range-based for loop was introduced to work with collections such as arrays and vectors.\n \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n/* For Loop Statement in C++ Language */\n// C++ program to find the sum of first n natural numbers\n// positive integers such as 1,2,3,...n are known as natural numbers\n#include <iostream>\nusing namespace std;\nint main() {\n int num, sum;\n sum = 0;\n cout << \"Enter a positive integer: \";\n cin >> num;\n for (int i = 1; i <= num; ++i) {\n sum += i;\n }\n cout << \"Sum = \" << sum << endl;\n return 0;\n}\n\n\n  Logical Operators in C++  Logical Operators are used to compare and connect two or more expressions or variables, such that the value of the expression is completely dependent on the original expression or value or variable.\nWe use logical operators to check whether an expression is true or false. If the expression is true, it returns 1 whereas if the expression is false, it returns 0.\nAssume variable A holds 1 and variable B holds 0:\n  &&  Called Logical AND operator. If both the operands are non-zero, then condition becomes true. (A && B) is false.\nThe logical AND operator && returns\n true - if and only if all the operands are true.\n false - if one or more operands are false.\n  ||  Called Logical OR Operator. If any of the two operands is non-zero, then condition becomes true. (A || B) is true.\nThe logical OR operator || returns\n true - if one or more of the operands are true.\n false - if and only if all the operands are false.\n  !  Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true, then Logical NOT operator will make false. !(A && B) is true.\nThe logical NOT operator ! is a unary operator i.e. it takes only one operand.\nIt returns true when the operand is false, and false when the operand is true.\n \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n/* The operator ! is the C++ operator for the Boolean operation NOT. It has only one operand, to its right, and inverts it, producing false if its operand is true, and true if its operand is false. Basically, it returns the opposite Boolean value of evaluating its operand.\nThe logical operators && and || are used when evaluating two expressions to obtain a single relational result. The operator && corresponds to the Boolean logical operation AND, which yields true if both its operands are true, and false otherwise. */\n#include <iostream>\nusing namespace std;\nmain() {\n int a = 5;\n int b = 20;\n int c ;\n if(a && b) {\n cout << \"Line 1 - Condition is true\"<< endl ;\n }\n if(a || b) {\n cout << \"Line 2 - Condition is true\"<< endl ;\n }\n /* Let's change the values of a and b */\n a = 0;\n b = 10;\n if(a && b) {\n cout << \"Line 3 - Condition is true\"<< endl ;\n } else {\n cout << \"Line 4 - Condition is not true\"<< endl ;\n }\n if(!(a && b)) {\n cout << \"Line 5 - Condition is true\"<< endl ;\n }\n return 0;\n}\n\n\n  What is an Array in C++ Language  An array is defined as the collection of similar type of data items stored at contiguous memory locations. Arrays are the derived data type in C++ programming language which can store the primitive type of data such as int, char, double, float, etc. It also has the capability to store the collection of derived data types, such as pointers, structure, etc. The array is the simplest data structure where each data element can be randomly accessed by using its index number.\nC++ array is beneficial if you have to store similar elements. For example, if we want to store the marks of a student in 6 subjects, then we don't need to define different variables for the marks in the different subject. Instead of that, we can define an array which can store the marks in each subject at the contiguous memory locations.\nBy using the array, we can access the elements easily. Only a few lines of code are required to access the elements of the array.\n  Properties of Array  The array contains the following properties.\n\u00e2\u0080\u00a2 Each element of an array is of same data type and carries the same size, i.e., int = 4 bytes.\n\u00e2\u0080\u00a2 Elements of the array are stored at contiguous memory locations where the first element is stored at the smallest memory location.\n\u00e2\u0080\u00a2 Elements of the array can be randomly accessed since we can calculate the address of each element of the array with the given base address and the size of the data element.\n  Advantage of C++ Array  \n\u00e2\u0080\u00a2 1) Code Optimization: Less code to the access the data.\n\u00e2\u0080\u00a2 2) Ease of traversing: By using the for loop, we can retrieve the elements of an array easily.\n\u00e2\u0080\u00a2 3) Ease of sorting: To sort the elements of the array, we need a few lines of code only.\n\u00e2\u0080\u00a2 4) Random Access: We can access any element randomly using the array.\n  Disadvantage of C++ Array  \n\u00e2\u0080\u00a2 1) Allows a fixed number of elements to be entered which is decided at the time of declaration. Unlike a linked list, an array in C++ is not dynamic.\n\u00e2\u0080\u00a2 2) Insertion and deletion of elements can be costly since the elements are needed to be managed in accordance with the new memory allocation.\n   Declaration of C++ Array   To declare an array in C++, a programmer specifies the type of the elements and the number of elements required by an array as follows\n  type arrayName [ arraySize ];  This is called a single-dimensional array. The arraySize must be an integer constant greater than zero and type can be any valid C++ data type. For example, to declare a 10-element array called balance of type double, use this statement\n Here balance is a variable array which is sufficient to hold up to 10 double numbers.\n   Initializing Arrays   You can initialize an array in C++ either one by one or using a single statement as follows\n  double balance[5] = {850, 3.0, 7.4, 7.0, 88};  The number of values between braces { } cannot be larger than the number of elements that we declare for the array between square brackets [ ].\nIf you omit the size of the array, an array just big enough to hold the initialization is created. Therefore, if you write\n  double balance[] = {850, 3.0, 7.4, 7.0, 88}; \n  Accessing Array Elements   An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array.\n  double salary = balance[9];  The above statement will take the 10th element from the array and assign the value to salary variable.\n \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n/* arrays in C++ Language */\n#include <iostream>\nusing namespace std;\nint main() {\n // initialize an array without specifying size\n double numbers[] = {7, 5, 6, 12, 35, 27};\n double sum = 0;\n double count = 0;\n double average;\n cout << \"The numbers are: \";\n // print array elements\n // use of range-based for loop\n for (const double &n : numbers) {\n cout << n << \" \";\n // calculate the sum\n sum += n;\n // count the no. of array elements\n ++count;\n }\n // print the sum\n cout << \"\\nTheir Sum = \" << sum << endl;\n // find the average\n average = sum / count;\n cout << \"Their Average = \" << average << endl;\n return 0;\n}\n\n\n  main() Function in C++  A program shall contain a global function named main, which is the designated start of the program in hosted environment. main() function is the entry point of any C++ program. It is the point at which execution of program is started. When a C++ program is executed, the execution control goes directly to the main() function. Every C++ program have a main() function.\n   Syntax for main() Function in C++  \n void main()\n{\n ............\n ............\n} \n void  void is a keyword in C++ language, void means nothing, whenever we use void as a function return type then that function nothing return. here main() function no return any value.\n  main  main is a name of function which is predefined function in C++ library.\nIn place of void we can also use int return type of main() function, at that time main() return integer type value.\n1) It cannot be used anywhere in the program\na) in particular, it cannot be called recursively\nb) its address cannot be taken\n2) It cannot be predefined and cannot be overloaded: effectively, the name main in the global namespace is reserved for functions (although it can be used to name classes, namespaces, enumerations, and any entity in a non-global namespace, except that a function called \"main\" cannot be declared with C language linkage in any namespace).\n3) It cannot be defined as deleted or (since C++11) declared with C language linkage, constexpr (since C++11), consteval (since C++20), inline, or static.\n4) The body of the main function does not need to contain the return statement: if control reaches the end of main without encountering a return statement, the effect is that of executing return 0;.\n5) Execution of the return (or the implicit return upon reaching the end of main) is equivalent to first leaving the function normally (which destroys the objects with automatic storage duration) and then calling std::exit with the same argument as the argument of the return. (std::exit then destroys static objects and terminates the program).\n6) (since C++14) The return type of the main function cannot be deduced (auto main() {... is not allowed).\n7) (since C++20) The main function cannot be a coroutine.\n \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n/* simple code example by main() function in C++ */\n#include <iostream>\nusing namespace std;\nint main() {\n int day = 4;\n switch (day) {\n case 1:\n cout << \"Monday\";\n break;\n case 2:\n cout << \"Tuesday\";\n break;\n case 3:\n cout << \"Wednesday\";\n break;\n case 4:\n cout << \"Thursday\";\n break;\n case 5:\n cout << \"Friday\";\n break;\n case 6:\n cout << \"Saturday\";\n break;\n case 7:\n cout << \"Sunday\";\n break;\n }\n return 0;\n}\n\n\n  Structures in C++ Language   In C++, classes and structs are blueprints that are used to create the instance of a class. Structs are used for lightweight objects such as Rectangle, color, Point, etc. Unlike class, structs in C++ are value type than reference type. It is useful if you have data that is not intended to be modified after creation of struct.\nC++ Structure is a collection of different data types. It is similar to the class that holds different types of data.\n   Syntax for Structures in C++  \n struct structureName{\n member1;\n member2;\n member3;\n .\n .\n .\n memberN;\n};  \nA structure is declared by preceding the struct keyword followed by the identifier(structure name). Inside the curly braces, we can declare the member variables of different types.\nConsider the following situation:\n   struct Teacher\n {\n char name[20];\n int id;\n int age;\n }   \nIn the above case, Teacher is a structure contains three variables name, id, and age. When the structure is declared, no memory is allocated. When the variable of a structure is created, then the memory is allocated. Let's understand this scenario.\nStructures in C++ can contain two types of members:\n\u00e2\u0080\u00a2 Data Member: These members are normal C++ variables. We can create a structure with variables of different data types in C++.\n\u00e2\u0080\u00a2 Member Functions: These members are normal C++ functions. Along with variables, we can also include functions inside a structure declaration.\nStructure variable can be defined as: Teacher s;\nHere, s is a structure variable of type Teacher. When the structure variable is created, the memory will be allocated. Teacher structure contains one char variable and two integer variable. Therefore, the memory for one char variable is 1 byte and two ints will be 2*4 = 8. The total memory occupied by the s variable is 9 byte.\nThe variable of the structure can be accessed by simply using the instance of the structure followed by the dot (.) operator and then the field of the structure.\n \nWe are accessing the id field of the structure Teacher by using the dot(.) operator and assigns the value 4 to the id field.\nIn C++, the struct keyword is optional before in declaration of a variable. In C, it is mandatory.\n \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n/* Structure is a collection of variables of different data types under a single name. It is similar to a class in that, both holds a collecion of data of different data types. */\n#include <iostream>\nusing namespace std;\nstruct Person\n{\n char name[50];\n int age;\n float salary;\n};\nint main()\n{\n Person p1;\n cout << \"Enter Full name: \";\n cin.get(p1.name, 50);\n cout << \"Enter age: \";\n cin >> p1.age;\n cout << \"Enter salary: \";\n cin >> p1.salary;\n cout << \"\\nDisplaying Information.\" << endl;\n cout << \"Name: \" << p1.name << endl;\n cout <<\"Age: \" << p1.age << endl;\n cout << \"Salary: \" << p1.salary;\n return 0;\n}\n\n\n  #include Directive in C++  #include is a way of including a standard or user-defined file in the program and is mostly written at the beginning of any C/C++ program. This directive is read by the preprocessor and orders it to insert the content of a user-defined or system header file into the following program. These files are mainly imported from an outside source into the current program. The process of importing such files that might be system-defined or user-defined is known as File Inclusion. This type of preprocessor directive tells the compiler to include a file in the source code program.\n   Syntax for #include Directive in C++  \n #include \"user-defined_file\"  \nIncluding using \" \": When using the double quotes(\" \"), the preprocessor access the current directory in which the source \"header_file\" is located. This type is mainly used to access any header files of the user's program or user-defined files.\n \nIncluding using <>: While importing file using angular brackets(<>), the the preprocessor uses a predetermined directory path to access the file. It is mainly used to access system header files located in the standard system directories.\nHeader File or Standard files: This is a file which contains C/C++ function declarations and macro definitions to be shared between several source files. Functions like the printf(), scanf(), cout, cin and various other input-output or other standard functions are contained within different header files. So to utilise those functions, the users need to import a few header files which define the required functions.\nUser-defined files: These files resembles the header files, except for the fact that they are written and defined by the user itself. This saves the user from writing a particular function multiple times. Once a user-defined file is written, it can be imported anywhere in the program using the #include preprocessor.\n\u00e2\u0080\u00a2 In #include directive, comments are not recognized. So in case of #include <a//b>, a//b is treated as filename.\n\u00e2\u0080\u00a2 In #include directive, backslash is considered as normal text not escape sequence. So in case of #include <a\\nb>, a\\nb is treated as filename.\n\u00e2\u0080\u00a2 You can use only comment after filename otherwise it will give error.\n \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n/* using #include directive in C language */\n#include <stdio.h>\nint main()\n{\n /*\n * C standard library printf function\n * defined in the stdio.h header file\n */\n printf(\"I love you Clementine\");\n printf(\"I love you so much\");\n printf(\"HappyCodings\");\n return 0;\n}\n\n\n  Standard Library malloc() Function in C++  Allocate memory block. Allocates a block of size bytes of memory, returning a pointer to the beginning of the block. The content of the newly allocated block of memory is not initialized, remaining with indeterminate values.\nIf size is zero, the return value depends on the particular library implementation (it may or may not be a null pointer), but the returned pointer shall not be dereferenced.\nMalloc function in C++ is used to allocate a specified size of the block of memory dynamically uninitialized. It allocates the memory to the variable on the heap and returns the void pointer pointing to the beginning address of the memory block. The values in the memory block allocated remain uninitialized and indeterminate. In case the size specified in the function is zero then pointer returned must not be dereferenced as it can be a null pointer, and in this case, behavior depends on particular library implementation. When a memory block is allocated dynamically memory is allocated on the heap but the pointer is allocated to the stack.\n   Syntax for malloc() Function in C++  \n #include <cstdlib>\nvoid* malloc (size_t size); \n size  Size of the memory block, in bytes. size_t is an unsigned integral type.\nOn success, a pointer to the memory block allocated by the function.\nThe type of this pointer is always void*, which can be cast to the desired type of data pointer in order to be dereferenceable.\nIf the function failed to allocate the requested block of memory, a null pointer is returned.\n  Advantages of malloc() in C++  There are a lot of advantages to using the malloc method in one's application:\n\u00e2\u0080\u00a2 Dynamic Memory allocation: Usually we create arrays at compile time in C++, the size of such arrays is fixed. In the case at run time we do not use all the space or extra space is required for more elements to be inserted in the array, then this leads to improper memory management or segmentation fault error.\n\u00e2\u0080\u00a2 Heap memory: Local arrays that are defined at compile time are allocated on the stack, which has lagged in memory management in case the number of data increases. Thus one needs to allocate memory out of the stack, thus malloc comes into the picture as it allocates the memory location on the heap and returns a pointer on the stack pointing to the starting address of the array type memory being allocated.\n\u00e2\u0080\u00a2 Variable-length array: This function helps to allocate memory for an array whose size can be defined at the runtime. Thus one can create the number of blocks as much as required at run time.\n\u00e2\u0080\u00a2 Better lifetime: Variable created using malloc method is proved to have a better life than the local arrays as a lifetime of local arrays depends on the scope they are being defined and cannot access out of their scope. But variables or arrays created using malloc exist till they are freed. This is of great importance for various data structures such as linked list, binary heap, etc.\n   Differences between the malloc() and new   \n\u00e2\u0080\u00a2 The new operator constructs an object, i.e., it calls the constructor to initialize an object while malloc() function does not call the constructor. The new operator invokes the constructor, and the delete operator invokes the destructor to destroy the object. This is the biggest difference between the malloc() and new.\n\u00e2\u0080\u00a2 The new is an operator, while malloc() is a predefined function in the stdlib header file.\n\u00e2\u0080\u00a2 The operator new can be overloaded while the malloc() function cannot be overloaded.\n\u00e2\u0080\u00a2 If the sufficient memory is not available in a heap, then the new operator will throw an exception while the malloc() function returns a NULL pointer.\n\u00e2\u0080\u00a2 In the new operator, we need to specify the number of objects to be allocated while in malloc() function, we need to specify the number of bytes to be allocated.\n\u00e2\u0080\u00a2 In the case of a new operator, we have to use the delete operator to deallocate the memory. But in the case of malloc() function, we have to use the free() function to deallocate the memory.\n  Data races  Only the storage referenced by the returned pointer is modified. No other storage locations are accessed by the call.\nIf the function reuses the same unit of storage released by a deallocation function (such as free or realloc), the functions are synchronized in such a way that the deallocation happens entirely before the next allocation.\n  Exceptions  No-throw guarantee: this function never throws exceptions.\n \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n/* allocate the requested size of bytes and it returns a pointer to the first byte of allocated memory by malloc() function code example. */\n#include <iostream>\n#include <cstdlib>\nusing namespace std;\nint main() {\n // allocate 5 int memory blocks\n int* ptr = (int*) malloc(5 * sizeof(int));\n // check if memory has been allocated successfully\n if (!ptr) {\n cout << \"Memory Allocation Failed\";\n exit(1);\n }\n cout << \"Initializing values...\" << endl << endl;\n for (int i = 0; i < 5; i++) {\n ptr[i] = i * 2 + 1;\n }\n cout << \"Initialized values\" << endl;\n // print the values in allocated memories\n for (int i = 0; i < 5; i++) {\n // ptr[i] and *(ptr+i) can be used interchangeably\n cout << *(ptr + i) << endl;\n }\n // deallocate memory\n free(ptr);\n return 0;\n}\n\n\n  If Else Statement in C++  In computer programming, we use the if statement to run a block code only when a certain condition is met. An if statement can be followed by an optional else statement, which executes when the boolean expression is false. There are three forms of if...else statements in C++:\n\u00e2\u0080\u00a2 if statement,\n\u00e2\u0080\u00a2 if...else statement,\n\u00e2\u0080\u00a2 if...else if...else statement,\n   Syntax for If Statement in C++  \n if (condition) {\n // body of if statement\n}  \nThe if statement evaluates the condition inside the parentheses ( ).\nIf the condition evaluates to true, the code inside the body of if is executed.\nIf the condition evaluates to false, the code inside the body of if is skipped.\n   Syntax for If...Else Statement  \n if (condition) {\n // block of code if condition is true\n}\nelse {\n // block of code if condition is false\n}  \nThe if..else statement evaluates the condition inside the parenthesis.\nIf the condition evaluates true,\n the code inside the body of if is executed,\n the code inside the body of else is skipped from execution.\nIf the condition evaluates false,\n the code inside the body of else is executed,\n the code inside the body of if is skipped from execution.\nThe if...else statement is used to execute a block of code among two alternatives. However, if we need to make a choice between more than two alternatives, we use the if...else if...else statement.\n   Syntax for If...Else...Else If Statement in C++  \n if (condition1) {\n // code block 1\n}\nelse if (condition2){\n // code block 2\n}\nelse {\n // code block 3\n}  \n\u00e2\u0080\u00a2 If condition1 evaluates to true, the code block 1 is executed.\n\u00e2\u0080\u00a2 If condition1 evaluates to false, then condition2 is evaluated.\n\u00e2\u0080\u00a2 If condition2 is true, the code block 2 is executed.\n\u00e2\u0080\u00a2 If condition2 is false, the code block 3 is executed.\nThere can be more than one else if statement but only one if and else statements.\nIn C/C++ if-else-if ladder helps user decide from among multiple options. The C/C++ if statements are executed from the top down. As soon as one of the conditions controlling the if is true, the statement associated with that if is executed, and the rest of the C else-if ladder is bypassed. If none of the conditions is true, then the final else statement will be executed.\n   Syntax for If Else If Ladder in C++  \n if (condition)\n statement 1;\nelse if (condition)\n statement 2;\n.\n.\nelse\n statement;  \nWorking of the if-else-if ladder:\n 1. Control falls into the if block.\n 2. The flow jumps to Condition 1.\n 3. Condition is tested.\n If Condition yields true, goto Step 4.\n If Condition yields false, goto Step 5.\n 4. The present block is executed. Goto Step 7.\n 5. The flow jumps to Condition 2.\n If Condition yields true, goto step 4.\n If Condition yields false, goto Step 6.\n 6. The flow jumps to Condition 3.\n If Condition yields true, goto step 4.\n If Condition yields false, execute else block. Goto Step 7.\n 7. Exits the if-else-if ladder.\n\u00e2\u0080\u00a2 The if else ladder statement in C++ programming language is used to check set of conditions in sequence.\n\u00e2\u0080\u00a2 This is useful when we want to selectively executes one code block(out of many) based on certain conditions.\n\u00e2\u0080\u00a2 It allows us to check for multiple condition expressions and execute different code blocks for more than two conditions.\n\u00e2\u0080\u00a2 A condition expression is tested only when all previous if conditions in if-else ladder is false.\n\u00e2\u0080\u00a2 If any of the conditional expression evaluates to true, then it will execute the corresponding code block and exits whole if-else ladder.\n \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n/* If Else Statement in C++ Language */\n#include <iostream>\nusing namespace std;\nint main () {\n // local variable declaration:\n int a = 100;\n // check the boolean condition\n if( a < 20 ) {\n // if condition is true then print the following\n cout << \"a is less than 20;\" << endl;\n } else {\n // if condition is false then print the following\n cout << \"a is not less than 20;\" << endl;\n }\n cout << \"value of a is : \" << a << endl;\n return 0;\n}\n\n\n\n\"Two dimensional\" (2D) array can be made in C++ Language by using two for loops, first is outer for loop and the second one is inner for loop. Outer for Loop is responsible for rows\n\n\n\n\n\n", "Skip to content\n Toggle navigation\n Sign up\n * Product\n + Actions\n Automate any workflow\n + Packages\n Host and manage packages\n + Security\n Find and fix vulnerabilities\n + Codespaces\n Instant dev environments\n + Copilot\n Write better code with AI\n + Code review\n Manage code changes\n + Issues\n Plan and track work\n + Discussions\n Collaborate outside of code\n + Explore\n + All features\n + Documentation\n + GitHub Skills\n + Blog\n * Solutions\n + For\n + Enterprise\n + Teams\n + Startups\n + Education\n + By Solution\n + CI/CD & Automation\n + DevOps\n + DevSecOps\n + Case Studies\n + Customer Stories\n + Resources\n * Open Source\n + GitHub Sponsors\n Fund open source developers\n + The ReadME Project\n GitHub community articles\n + Repositories\n + Topics\n + Trending\n + Collections\n * Pricing\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n * No suggested jump to results\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n * In this user All GitHub \u21b5\n Jump to \u21b5\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n Sign in\n Sign up\n {{ message }}\n hamzaelanssari / Shortest-path-algorithm-with-C Public\n * Notifications\n * Fork 0\n * Star 1\n\n shortest path between cities with language C\n\n 1 star 0 forks\n Star\n Notifications\n * Code\n * Issues 0\n * Pull requests 0\n * Actions\n * Projects 0\n * Security\n * Insights\n More\n * Code\n * Issues\n * Pull requests\n * Actions\n * Projects\n * Security\n * Insights\n\n hamzaelanssari/Shortest-path-algorithm-with-C\n\n This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.\n master\n Switch branches/tags\n Branches Tags\n Could not load branches\n Nothing to show\n {{ refName }} default\n View all branches\n Could not load tags\n Nothing to show\n {{ refName }} default\n View all tags\n\n Name already in use\n\n A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch?\n Cancel Create\n 1 branch 0 tags\n Code\n * Local\n * Codespaces\n * Clone\n HTTPS GitHub CLI\n\n Use Git or checkout with SVN using the web URL.\n\n Work fast with our official CLI. Learn more.\n\n * Open with GitHub Desktop\n * Download ZIP\n\n Sign In Required\n\n Please sign in to use Codespaces.\n\n Launching GitHub Desktop\n\n If nothing happens, download GitHub Desktop and try again.\n\n Launching GitHub Desktop\n\n If nothing happens, download GitHub Desktop and try again.\n\n Launching Xcode\n\n If nothing happens, download Xcode and try again.\n\n Launching Visual Studio Code\n\n Your codespace will open once ready.\n\n There was a problem preparing your codespace, please try again.\n\n Latest commit\n\n Git stats\n\n * 2 commits\n\n Files\n\n Permalink\n Failed to load latest commit information.\n Type\n Name\n Latest commit message\n Commit time\n Aeroport_Bellman_Ford.cpp\n README.md\n View code\n\n README.md\n\n Shortest-path-algorithm-with-C\n\n shortest path between cities with language C the goal of this algorithm is to specify the short bath between cities(Airports). you can enter the number of airports and the distance between each airport.\n\n About\n\n shortest path between cities with language C\n\n Resources\n\n Readme\n\n Stars\n\n 1 star\n\n Watchers\n\n 1 watching\n\n Forks\n\n 0 forks\n\n Releases\n\n No releases published\n\n Packages 0\n\n No packages published\n\n Languages\n\n * C++ 100.0%\n\n Footer\n\n \u00a9 2023 GitHub, Inc.\n\n Footer navigation\n\n * Terms\n * Privacy\n * Security\n * Status\n * Docs\n * Contact GitHub\n * Pricing\n * API\n * Training\n * Blog\n * About\n You can\u2019t perform that action at this time.\n You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.", "Skip to content\n Toggle navigation\n Sign up\n * Product\n + Actions\n Automate any workflow\n + Packages\n Host and manage packages\n + Security\n Find and fix vulnerabilities\n + Codespaces\n Instant dev environments\n + Copilot\n Write better code with AI\n + Code review\n Manage code changes\n + Issues\n Plan and track work\n + Discussions\n Collaborate outside of code\n + Explore\n + All features\n + Documentation\n + GitHub Skills\n + Blog\n * Solutions\n + For\n + Enterprise\n + Teams\n + Startups\n + Education\n + By Solution\n + CI/CD & Automation\n + DevOps\n + DevSecOps\n + Case Studies\n + Customer Stories\n + Resources\n * Open Source\n + GitHub Sponsors\n Fund open source developers\n + The ReadME Project\n GitHub community articles\n + Repositories\n + Topics\n + Trending\n + Collections\n * Pricing\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n * No suggested jump to results\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n * In this user All GitHub \u21b5\n Jump to \u21b5\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n Sign in\n Sign up\n {{ message }}\n gracexiaoyan / Dijkstra Public\n * Notifications\n * Fork 0\n * Star 1\n\n Dijkstra to get the shortest distance in directed graph\n\n 1 star 0 forks\n Star\n Notifications\n * Code\n * Issues 0\n * Pull requests 0\n * Actions\n * Projects 0\n * Security\n * Insights\n More\n * Code\n * Issues\n * Pull requests\n * Actions\n * Projects\n * Security\n * Insights\n\n gracexiaoyan/Dijkstra\n\n This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.\n master\n Switch branches/tags\n Branches Tags\n Could not load branches\n Nothing to show\n {{ refName }} default\n View all branches\n Could not load tags\n Nothing to show\n {{ refName }} default\n View all tags\n\n Name already in use\n\n A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch?\n Cancel Create\n 1 branch 0 tags\n Code\n * Local\n * Codespaces\n * Clone\n HTTPS GitHub CLI\n\n Use Git or checkout with SVN using the web URL.\n\n Work fast with our official CLI. Learn more.\n\n * Open with GitHub Desktop\n * Download ZIP\n\n Sign In Required\n\n Please sign in to use Codespaces.\n\n Launching GitHub Desktop\n\n If nothing happens, download GitHub Desktop and try again.\n\n Launching GitHub Desktop\n\n If nothing happens, download GitHub Desktop and try again.\n\n Launching Xcode\n\n If nothing happens, download Xcode and try again.\n\n Launching Visual Studio Code\n\n Your codespace will open once ready.\n\n There was a problem preparing your codespace, please try again.\n\n Latest commit\n\n Git stats\n\n * 1 commit\n\n Files\n\n Permalink\n Failed to load latest commit information.\n Type\n Name\n Latest commit message\n Commit time\n src/com/grace/ dijkstra\n View code\n\n About\n\n Dijkstra to get the shortest distance in directed graph\n\n Stars\n\n 1 star\n\n Watchers\n\n 1 watching\n\n Forks\n\n 0 forks\n\n Releases\n\n No releases published\n\n Packages 0\n\n No packages published\n\n Languages\n\n * Java 100.0%\n\n Footer\n\n \u00a9 2023 GitHub, Inc.\n\n Footer navigation\n\n * Terms\n * Privacy\n * Security\n * Status\n * Docs\n * Contact GitHub\n * Pricing\n * API\n * Training\n * Blog\n * About\n You can\u2019t perform that action at this time.\n You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.", "# prim - minimum spanning tree\n# Tim Wilson, 2-25-2002\n#A = adjacency matrix, u = vertex u, v = vertex v\ndef weight(A, u, v):\n return A[u][v]\n#A = adjacency matrix, u = vertex u\ndef adjacent(A, u):\n L = []\n for x in range(len(A)):\n if A[u][x] > 0 and x <> u:\n L.insert(0,x)\n return L\n#Q = min queue\ndef extractMin(Q):\n q = Q[0]\n Q.remove(Q[0])\n return q\n#Q = min queue, V = vertex list\ndef decreaseKey(Q, K):\n for i in range(len(Q)):\n for j in range(len(Q)):\n if K[Q[i]] < K[Q[j]]:\n s = Q[i]\n Q[i] = Q[j]\n Q[j] = s\n#V = vertex list, A = adjacency list, r = root\ndef prim(V, A, r):\n u = 0\n v = 0\n # initialize and set each value of the array P (pi) to none\n # pi holds the parent of u, so P(v)=u means u is the parent of v\n P=[None]*len(V)\n # initialize and set each value of the array K (key) to some large number (simulate infinity)\n K = [999999]*len(V)\n # initialize the min queue and fill it with all vertices in V\n Q=[0]*len(V)\n for u in range(len(Q)):\n Q[u] = V[u]\n # set the key of the root to 0\n K[r] = 0\n decreaseKey(Q, K) # maintain the min queue\n # loop while the min queue is not empty\n while len(Q) > 0:\n u = extractMin(Q) # pop the first vertex off the min queue\n # loop through the vertices adjacent to u\n Adj = adjacent(A, u)\n for v in Adj:\n w = weight(A, u, v) # get the weight of the edge uv\n # proceed if v is in Q and the weight of uv is less than v's key\n if Q.count(v)>0 and w < K[v]:\n # set v's parent to u\n P[v] = u\n # v's key to the weight of uv\n K[v] = w\n decreaseKey(Q, K) # maintain the min queue\n return P\nA = [ [0, 4, 0, 0, 0, 0, 0, 8, 0],\n [4, 0, 8, 0, 0, 0, 0, 11, 0],\n [0, 8, 0, 7, 0, 4, 0, 0, 2],\n [0, 0, 7, 0, 9, 14, 0, 0, 0],\n [0, 0, 0, 9, 0, 10, 0, 0, 0],\n [0, 0, 4, 14, 10, 0, 2, 0, 0],\n [0, 0, 0, 0, 0, 2, 0, 1, 6],\n [8, 11, 0, 0, 0, 0, 1, 0, 7],\n [0, 0, 2, 0, 0, 0, 6, 7, 0]]\nV = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]\nP = prim(V, A, 0)\nprint P\n[None, 0, 5, 2, 3, 6, 7, 0, 2]\n", "Skip to content\n Toggle navigation\n Sign up\n * Product\n + Actions\n Automate any workflow\n + Packages\n Host and manage packages\n + Security\n Find and fix vulnerabilities\n + Codespaces\n Instant dev environments\n + Copilot\n Write better code with AI\n + Code review\n Manage code changes\n + Issues\n Plan and track work\n + Discussions\n Collaborate outside of code\n + Explore\n + All features\n + Documentation\n + GitHub Skills\n + Blog\n * Solutions\n + For\n + Enterprise\n + Teams\n + Startups\n + Education\n + By Solution\n + CI/CD & Automation\n + DevOps\n + DevSecOps\n + Case Studies\n + Customer Stories\n + Resources\n * Open Source\n + GitHub Sponsors\n Fund open source developers\n + The ReadME Project\n GitHub community articles\n + Repositories\n + Topics\n + Trending\n + Collections\n * Pricing\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n * No suggested jump to results\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n * In this user All GitHub \u21b5\n Jump to \u21b5\n * In this repository All GitHub \u21b5\n Jump to \u21b5\n Sign in\n Sign up\n {{ message }}\n matrixgardener / AlgorithmCode Public\n * Notifications\n * Fork 6\n * Star 94\n\n algorithm code\n\n 94 stars 6 forks\n Star\n Notifications\n * Code\n * Issues 0\n * Pull requests 0\n * Actions\n * Projects 0\n * Security\n * Insights\n More\n * Code\n * Issues\n * Pull requests\n * Actions\n * Projects\n * Security\n * Insights\n\n matrixgardener/AlgorithmCode\n\n This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.\n master\n Switch branches/tags\n Branches Tags\n Could not load branches\n Nothing to show\n {{ refName }} default\n View all branches\n Could not load tags\n Nothing to show\n {{ refName }} default\n View all tags\n\n Name already in use\n\n A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch?\n Cancel Create\n 1 branch 0 tags\n Code\n * Local\n * Codespaces\n * Clone\n HTTPS GitHub CLI\n\n Use Git or checkout with SVN using the web URL.\n\n Work fast with our official CLI. Learn more.\n\n * Open with GitHub Desktop\n * Download ZIP\n\n Sign In Required\n\n Please sign in to use Codespaces.\n\n Launching GitHub Desktop\n\n If nothing happens, download GitHub Desktop and try again.\n\n Launching GitHub Desktop\n\n If nothing happens, download GitHub Desktop and try again.\n\n Launching Xcode\n\n If nothing happens, download Xcode and try again.\n\n Launching Visual Studio Code\n\n Your codespace will open once ready.\n\n There was a problem preparing your codespace, please try again.\n\n Latest commit\n\n Git stats\n\n * 5 commits\n\n Files\n\n Permalink\n Failed to load latest commit information.\n Type\n Name\n Latest commit message\n Commit time\n .gitattributes\n .gitignore\n Dijkstra.cpp\n README.md\n \u52a0\u52d2\u6bd4\u6d77\u76d7\u95ee\u9898.cpp\n View code\n\n README.md\n\n AlgorithmCode\n\n \u6b64\u6587\u6863\u662f\u7ec3\u4e60\u7b97\u6cd5\n\n About\n\n algorithm code\n\n Resources\n\n Readme\n\n Stars\n\n 94 stars\n\n Watchers\n\n 0 watching\n\n Forks\n\n 6 forks\n\n Releases\n\n No releases published\n\n Packages 0\n\n No packages published\n\n Languages\n\n * C++ 100.0%\n\n Footer\n\n \u00a9 2023 GitHub, Inc.\n\n Footer navigation\n\n * Terms\n * Privacy\n * Security\n * Status\n * Docs\n * Contact GitHub\n * Pricing\n * API\n * Training\n * Blog\n * About\n You can\u2019t perform that action at this time.\n You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."]}